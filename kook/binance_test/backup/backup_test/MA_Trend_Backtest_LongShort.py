'''

ë¶„í•  ì§„ì… ë¹„ìœ¨ì€ ATRì„ ì ‘ëª©í•˜ê³ , 2ì°¨ í•¨ìˆ˜ë¥¼ ì´ìš©í•˜ì—¬ ë¹„ì„ í˜•ìœ¼ë¡œ, ì¼ì¢…ì˜ ë¡œê·¸ ê·¸ë˜í”„ í˜•íƒœë¡œ ì§„ì…í•˜ê¸° ë•Œë¬¸ì— ë‹¹ì¼ì˜ ê°€ê²© ë³€ë™í­ì— ë”°ë¼ì„œ ë‹¬ë¼ì ¸ì„œ ë”± ì–¼ë§ˆë¼ê³  ê·œì •ì§“ì§€ ì•ŠìŠµë‹ˆë‹¤.
ë“œì´ì–´, Machine Learningë„ ë„ì…í•˜ì—¬ í”„ë¡œê·¸ë¨ ëŒë¦¬ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤. ã…

ë¡œì§ì€ ë‹¤ë¥¸ê±° í•˜ë‚˜ ì—†ì´ ì´í‰ì„  ë‘ê°œë¡œë§Œ ì‹ í˜¸íŠ¸ë¦¬ê±°ë¡œ ì¼ëŠ”ë°...
ë¨¸ì‹ ëŸ¬ë‹ê³¼ ì˜¤í† íŠœë‹, ë°ì´í„° ì„ê³„ì¹˜ ìë™íŠœë‹ ë“±ì„ ë¡œì§ì— ë‹´ë‹¤ ë³´ë‹ˆ ì‹œê°„ì´ ë§ì´ ì†Œìš”ë˜ì—ˆë„¤ìš”

íŠ¹ë³„í•  ê²ƒë„ ì—†ì–´ìš” ê·¸ëƒ¥ ì´ë™í‰ê· ì„  ë‘ê°œë§Œ ì„¸íŒ…í•´ì„œ í˜„ì¬ê°€ê°€ ì´í‰ì„  ìœ„ë¡œ ëŒíŒŒí•˜ë©´ ë§¤ìˆ˜, ì•„ë˜ë¡œ ëŒíŒŒí•˜ë©´ ë§¤ë„...ê°„ë‹¨í•œ ë¡œì§ì´ì˜ˆìš” ã…‹

ì•„...ë¡œì§ ìì²´ëŠ” ë‹¨ìˆœí•œë°, ë§¤ë§¤ì½”ë“œì— íŒŒë¼ë¯¸í„° ì˜¤í† íŠœë‹, í”¼ì²˜ë°ì´í„° ë¨¸ì‹ ëŸ¬ë‹ˆ, í™˜ê²½ë³€ìˆ˜ ì£¼ê¸°ì ì¸ ëª¨ë‹ˆí„°ë§ë° ë¦¬íŒŒì¸ ë“± ì—¬ëŸ¬ê°€ì§€ë¥¼ ì¶”ê°€í•˜ëŠë¼ ì˜í˜¼ê¹Œì§€ ê°ˆì•„ë„£ì€ê²ë‹ˆë‹¤. ã…‹

ì¦‰, ê·¸ëƒ¥ ë‹¨ìˆœí•˜ê²Œ ì´ë™í‰ê· ì„  ê³ ì •ì´ ì•„ë‹ˆë¼ ì£¼ê¸°ì ìœ¼ë¡œ ì´ë™í‰ê· ì„ ì„ ì˜¤í† íŠœë‹í•´ì„œ ì¬ì„¤ì • í•´ ì£¼ê³ , ë³¼ë¦°ì €ë°´ë“œ, ìŠ¤í† ìºìŠ¤í‹±, macd ë“± 21ê°€ì§€ ë³´ì¡°ì§€í‘œë¥¼ ë°˜ë³µí•™ìŠµ í•˜ê³ , ê·¸ ë°˜ë³µí•™ìŠµ í•œ ê³Œê³¼ê°’ìœ¼ë¡œ í•œ ë‹¬ì— í•œë²ˆì”© ìë™ìœ¼ë¡œ ì ìš©í•˜ê³ , ì„ê³„ê°’ì„ ë˜ íŠœë‹í•˜ëŠ”...
ì¢€ ë§ì´ ë³µì¡í•œ ë¡œì§ì´ë¼...ë‹¤ ë§Œë“¤ê³  ë‚˜ë‹ˆê¹Œ ë¼ì¸ìˆ˜ê°€ 3,000ì¤„ì´ ë„˜ì–´ê°€ë„¤ìš” ã…‹

ì´ë¯¸ ë°±í…Œ í•˜ê³  ê³¼ìµœì í™”, ë£©ì–´í—¤ë“œë°”ì´ì–´ìŠ¤ ë‹¤ ì¡ì€ ë² ìŠ¤íŠ¸ íŒŒë¼ë¯¸í„°ë¡œ ìµœì´ˆ ì‹¤í–‰...
í•œë‹¬ í›„ë¶€í„° ë‹¤ì‹œ ì˜¤í† íŠœë‹ê³¼ ë¨¸ì‹ ëŸ¬ë‹ ë“œë¦¬í”„íŠ¸ëª¨ë‹ˆí„°ë§ ì´ë ‡ê²Œ 3ê°€ì§€ë¥¼ ëŒë¦¬ëŠ” êµ¬ì¡°ë¼ì„œ...

ë ˆë²„ë¦¬ì§€ 10ë°°

ì €ëŠ” ê·¸ëƒ¥ ì‹¤í–‰ë§Œ í•´ ë‘ë©´ ì§€ê°€ ì•Œì•„ì„œ ë‹¤ ëŒì•„ê°€ë„ë¡ ì„¸íŒ…í•´ì„œ, ì²˜ìŒ ë°±í…Œ í•  ë•Œ ìŠ¬ë¦¬í”¼ì§€, í€ë¹„ ë‹¤ ë°˜ì˜í•˜ê²Œ ë§Œë“¤ì–´ì„œ...
ë§ ê·¸ëŒ€ë¡œ íŒŒë¼ë¯¸í„°ì™€ í”¼ì²˜ì„ê³„ì¹˜ ì„¤ì •ê¹Œì§€ ìë™ íŠœë‹í•˜ê²Œ ë§Œë“¤ì—ˆì–´ìš” ã…
'''


#-*-coding:utf-8 -*-
import os
import sys
import json
import glob
import datetime
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from matplotlib import rcParams

# í•œê¸€ í°íŠ¸ ì„¤ì •
rcParams['font.family'] = 'DejaVu Sans'
rcParams['axes.unicode_minus'] = False

def calculate_ma(df, period):
    """Simple Moving Average ê³„ì‚°"""
    return df['close'].rolling(period).mean()

def backtest_strategy(df, ma1, ma2, initial_capital, leverage, fee=0.001, strategy_type='LONG', trend_params=None, use_trend=True):
    """MA + ì¶”ì„¸ + ë³¼ë¥¨ í•„í„° í•˜ì´ë¸Œë¦¬ë“œ ë°±í…ŒìŠ¤íŠ¸ ì „ëµ"""
    if len(df) < max(ma1, ma2):
        return None
    
    # ê¸°ë³¸ ì§€í‘œ ê³„ì‚°
    df['momentum_5'] = df['close'].pct_change(5)
    df['momentum_10'] = df['close'].pct_change(10)
    df['trend_direction'] = np.where(df['close'] > df['close'].shift(1), 1, -1)
    df['trend_continuity'] = df['trend_direction'].rolling(5).sum()
    df['bb_upper'] = df['close'].rolling(20).mean() + 2 * df['close'].rolling(20).std()
    df['bb_lower'] = df['close'].rolling(20).mean() - 2 * df['close'].rolling(20).std()
    df['bb_position'] = (df['close'] - df['bb_lower']) / (df['bb_upper'] - df['bb_lower'])
    
    # RSI ê³„ì‚°
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs))
    df.dropna(inplace=True)
    
    # MA ê³„ì‚°
    df[f'ma_{ma1}'] = df['close'].rolling(ma1).mean()
    df[f'ma_{ma2}'] = df['close'].rolling(ma2).mean()
    
    # ê¸°ë³¸ íŒŒë¼ë¯¸í„°
    if trend_params is None:
        trend_params = {
            'trend_continuity_min': 4,
            'rsi_oversold': 25,
            'rsi_overbought': 90,
            'momentum_period': 5
        }
    
    # ì „ëµ ë³€ìˆ˜
    position = 0  # 0: ì—†ìŒ, 1: ë¡±, -1: ìˆ
    entry_price = 0
    entry_time = None
    capital = initial_capital
    trades = []
    equity_curve = []
    
    # ë°±í…ŒìŠ¤íŠ¸ ì‹¤í–‰
    for i in range(max(ma1, ma2), len(df)):
        current_time = df.index[i]
        current_price = df['close'].iloc[i]
        close_prev = df['close'].iloc[i-1]
        
        # MA ì‹ í˜¸
        ma1_prev = df[f'ma_{ma1}'].iloc[i-1]
        ma2_prev = df[f'ma_{ma2}'].iloc[i-1]
        ma1_prev2 = df[f'ma_{ma1}'].iloc[i-2]
        ma2_prev2 = df[f'ma_{ma2}'].iloc[i-2]
        
        # ì¶”ì„¸ ì‹ í˜¸ (í•˜ì´ë¸Œë¦¬ë“œ ëª¨ë“œì¼ ë•Œ)
        trend_signal = 0
        if use_trend and i >= 20:
            momentum_5 = df['momentum_5'].iloc[i]
            momentum_10 = df['momentum_10'].iloc[i]
            trend_continuity = df['trend_continuity'].iloc[i]
            bb_position = df['bb_position'].iloc[i]
            rsi = df['rsi'].iloc[i]
            
            # JSONì—ì„œ ê°€ì ¸ì˜¨ ì¶”ì„¸ íŒŒë¼ë¯¸í„° ì‚¬ìš©
            if trend_params:
                trend_continuity_min = trend_params.get('trend_continuity_min', 2)
                rsi_oversold = trend_params.get('rsi_oversold', 50)
                rsi_overbought = trend_params.get('rsi_overbought', 80)
                momentum_period = trend_params.get('momentum_period', 5)
            else:
                # ê¸°ë³¸ê°’ (fallback)
                trend_continuity_min = 2
                rsi_oversold = 50
                rsi_overbought = 80
                momentum_period = 5
            
            # ì¶”ì„¸ ì‹ í˜¸ ìƒì„± (JSON íŒŒë¼ë¯¸í„° ê¸°ë°˜)
            if (momentum_5 > 0 and momentum_10 > 0 and  # ëª¨ë©˜í…€ ì–‘ìˆ˜
                trend_continuity >= trend_continuity_min and  # JSONì—ì„œ ê°€ì ¸ì˜¨ ì—°ì† ìƒìŠ¹ ê¸°ì¤€
                bb_position > 0.3 and                     # ë³¼ë¦°ì € ë°´ë“œ 0.3 ì´ìƒ
                rsi > rsi_oversold and                    # JSONì—ì„œ ê°€ì ¸ì˜¨ RSI ê³¼ë§¤ë„ ê¸°ì¤€
                rsi < rsi_overbought):                    # JSONì—ì„œ ê°€ì ¸ì˜¨ RSI ê³¼ë§¤ìˆ˜ ê¸°ì¤€
                trend_signal = 1  # ìƒìŠ¹ ì¶”ì„¸
        
        # ë¡± ì§„ì… ì‹ í˜¸ (MA + ì¶”ì„¸ ì¡°í•©)
        if strategy_type == 'LONG' and position == 0:
            # ë³¼ë¥¨ í•„í„°
            volume_filter = False
            if i >= 20:
                current_volume = df['volume'].iloc[i] if 'volume' in df.columns else 1000
                avg_volume = df['volume'].rolling(20).mean().iloc[i] if 'volume' in df.columns else 1000
                volume_filter = current_volume > avg_volume * 1.2
            
            # MA ì‹ í˜¸
            ma_signal = (close_prev >= ma1_prev and ma1_prev2 <= ma1_prev and 
                        close_prev >= ma2_prev and ma2_prev2 <= ma2_prev)
            
            # ì¶”ì„¸ ì‹ í˜¸ì™€ ì¡°í•© - ì¶”ì„¸ ì „ëµ ìš°ì„ 
            if use_trend:
                # ì¶”ì„¸ ì „ëµì´ í™œì„±í™”ë˜ë©´ ë” ìœ ì—°í•œ ì§„ì… ì¡°ê±´
                if trend_signal == 1:
                    # ì¶”ì„¸ ì‹ í˜¸ê°€ ìˆìœ¼ë©´ MA ì¡°ê±´ ì™„í™” ë˜ëŠ” ì¶”ì„¸ë§Œìœ¼ë¡œ ì§„ì…
                    entry_condition = ((close_prev >= ma1_prev or close_prev >= ma2_prev) or 
                                     (trend_continuity >= 3 and momentum_5 > 0 and momentum_10 > 0)) and (i < 20 or volume_filter)
                else:
                    # ì¶”ì„¸ ì‹ í˜¸ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ MA ì¡°ê±´
                    entry_condition = ma_signal and (i < 20 or volume_filter)
            else:
                entry_condition = ma_signal and (i < 20 or volume_filter)
            
            if entry_condition:
                position = 1
                entry_price = current_price
                entry_time = current_time
        
        # ìˆ ì§„ì… ì‹ í˜¸ (MA + ì¶”ì„¸ ì¡°í•©)
        elif strategy_type == 'SHORT' and position == 0:
            # ë³¼ë¥¨ í•„í„°
            volume_filter = False
            if i >= 20:
                current_volume = df['volume'].iloc[i] if 'volume' in df.columns else 1000
                avg_volume = df['volume'].rolling(20).mean().iloc[i] if 'volume' in df.columns else 1000
                volume_filter = current_volume > avg_volume * 1.2
            
            # MA ì‹ í˜¸
            ma_signal_short = (close_prev <= ma1_prev and ma1_prev2 >= ma1_prev and 
                              close_prev <= ma2_prev and ma2_prev2 >= ma2_prev)
            
            # ì¶”ì„¸ ì‹ í˜¸ì™€ ì¡°í•© - ì¶”ì„¸ ì „ëµ ìš°ì„ 
            if use_trend:
                # ì¶”ì„¸ ì „ëµì´ í™œì„±í™”ë˜ë©´ ë” ìœ ì—°í•œ ì§„ì… ì¡°ê±´
                if trend_signal == 1:
                    # ì¶”ì„¸ ì‹ í˜¸ê°€ ìˆìœ¼ë©´ MA ì¡°ê±´ ì™„í™” ë˜ëŠ” ì¶”ì„¸ë§Œìœ¼ë¡œ ì§„ì…
                    entry_condition = ((close_prev <= ma1_prev or close_prev <= ma2_prev) or 
                                     (trend_continuity <= -3 and momentum_5 < 0 and momentum_10 < 0)) and (i < 20 or volume_filter)
                else:
                    # ì¶”ì„¸ ì‹ í˜¸ê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ MA ì¡°ê±´
                    entry_condition = ma_signal_short and (i < 20 or volume_filter)
            else:
                entry_condition = ma_signal_short and (i < 20 or volume_filter)
            
            if entry_condition:
                position = -1
                entry_price = current_price
                entry_time = current_time
        
        # ë¡± í¬ì§€ì…˜ ì²­ì‚°
        elif strategy_type == 'LONG' and position == 1:
            # ë¡± ì²­ì‚°: MA ë°ë“œí¬ë¡œìŠ¤ ë˜ëŠ” ì†ì ˆ
            if (close_prev < ma1_prev and ma1_prev2 > ma1_prev) or \
               (close_prev < ma2_prev and ma2_prev2 > ma2_prev) or \
               (current_price <= entry_price * 0.95):  # 5% ì†ì ˆ
                exit_price = current_price
                pnl = (exit_price - entry_price) / entry_price * leverage
                capital *= (1 + pnl - fee * 2)  # ì§„ì…/ì²­ì‚° ìˆ˜ìˆ˜ë£Œ
                
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': current_time,
                    'entry_price': entry_price,
                    'exit_price': exit_price,
                    'pnl': pnl,
                    'capital': capital
                })
                
                position = 0
                entry_price = 0
                entry_time = None
        
        # ìˆ í¬ì§€ì…˜ ì²­ì‚°
        elif strategy_type == 'SHORT' and position == -1:
            # ìˆ ì²­ì‚°: MA ê³¨ë“ í¬ë¡œìŠ¤ ë˜ëŠ” ì†ì ˆ
            if (close_prev > ma1_prev and ma1_prev2 < ma1_prev) or \
               (close_prev > ma2_prev and ma2_prev2 < ma2_prev) or \
               (current_price >= entry_price * 1.05):  # 5% ì†ì ˆ
                exit_price = current_price
                pnl = (entry_price - exit_price) / entry_price * leverage
                capital *= (1 + pnl - fee * 2)  # ì§„ì…/ì²­ì‚° ìˆ˜ìˆ˜ë£Œ
                
                trades.append({
                    'entry_time': entry_time,
                    'exit_time': current_time,
                    'entry_price': entry_price,
                    'exit_price': exit_price,
                    'pnl': pnl,
                    'capital': capital
                })
                
                position = 0
                entry_price = 0
                entry_time = None
        
        # ìì‚° ê³¡ì„  ê¸°ë¡
        equity_curve.append({
            'time': current_time,
            'equity': capital,
            'price': current_price
        })
    
    # ë§ˆì§€ë§‰ í¬ì§€ì…˜ ì²­ì‚°
    if position != 0:
        exit_price = df['close'].iloc[-1]
        if strategy_type == 'LONG':
            pnl = (exit_price - entry_price) / entry_price * leverage
        else:
            pnl = (entry_price - exit_price) / entry_price * leverage
        
        capital *= (1 + pnl - fee)
        trades.append({
            'entry_time': entry_time,
            'exit_time': df.index[-1],
            'entry_price': entry_price,
            'exit_price': exit_price,
            'pnl': pnl,
            'capital': capital
        })
    
    # ê²°ê³¼ ê³„ì‚°
    total_return = (capital - initial_capital) / initial_capital * 100
    
    # MDD ê³„ì‚°
    peak = initial_capital
    mdd = 0
    for point in equity_curve:
        if point['equity'] > peak:
            peak = point['equity']
        drawdown = (peak - point['equity']) / peak * 100
        if drawdown > mdd:
            mdd = drawdown
    
    return {
        'total_return': total_return,
        'final_capital': capital,
        'trades': trades,
        'equity_curve': equity_curve,
        'mdd': mdd,
        'trade_count': len(trades)
    }

def load_optimized_parameters(json_file_path):
    """ìµœì í™”ëœ íŒŒë¼ë¯¸í„° ë¡œë“œ"""
    try:
        with open(json_file_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        print(f"íŒŒë¼ë¯¸í„° íŒŒì¼ ë¡œë“œ ì‹¤íŒ¨: {e}")
        return None

def main():
    # ìŠ¤í¬ë¦½íŠ¸ ë””ë ‰í† ë¦¬
    script_dir = os.path.dirname(os.path.abspath(__file__))
    
    # íŒŒë¼ë¯¸í„° íŒŒì¼ ê²½ë¡œ
    json_file_path = os.path.join(script_dir, 'MA_Trend_Backtest.json')
    
    # ìµœì í™”ëœ íŒŒë¼ë¯¸í„° ë¡œë“œ
    monthly_parameters = load_optimized_parameters(json_file_path)
    if not monthly_parameters:
        print("íŒŒë¼ë¯¸í„°ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return
    
    # ì›”ë³„ íŒŒë¼ë¯¸í„°ë¥¼ ìˆ˜ë™ìœ¼ë¡œ 2024ë…„ 1ì›”ë¶€í„° ìˆœì„œëŒ€ë¡œ ì •ë ¬
    sorted_monthly_parameters = {}
    
    # 2024ë…„ 1ì›”ë¶€í„° 2025ë…„ 8ì›”ê¹Œì§€ ìˆœì„œëŒ€ë¡œ ì •ë ¬
    ordered_months = []
    for year in [2024, 2025]:
        for month in range(1, 13):
            if year == 2025 and month > 8:  # 2025ë…„ 8ì›”ê¹Œì§€ë§Œ
                break
            month_key = f"{year}_{month:02d}"
            if month_key in monthly_parameters:
                ordered_months.append(month_key)
    
    # ìˆœì„œëŒ€ë¡œ ë”•ì…”ë„ˆë¦¬ ìƒì„±
    for month_key in ordered_months:
        sorted_monthly_parameters[month_key] = monthly_parameters[month_key]
    
    monthly_parameters = sorted_monthly_parameters
    print(f"ğŸ“… ìˆ˜ë™ ì •ë ¬ëœ ì›”ë³„ íŒŒë¼ë¯¸í„°: {list(monthly_parameters.keys())}")
    print(f"ğŸ“Š ì´ {len(monthly_parameters)}ê°œì›” ë°±í…ŒìŠ¤íŠ¸ ì˜ˆì •")
    
    # ë°±í…ŒìŠ¤íŠ¸ ì„¤ì •
    ticker = 'BTC/USDT'
    initial_capital = 10000  # ê¸°ë³¸ê°’
    leverage = 5  # ê¸°ë³¸ê°’
    
    print(f"\n{ticker} ë¡œì»¬ CSV ë°ì´í„° ë¡œë“œ ì¤‘...")
    
    # 2024ë…„ë¶€í„° í˜„ì¬ê¹Œì§€ì˜ CSV íŒŒì¼ë“¤ ë¡œë“œ
    data_dir = os.path.join(script_dir, 'data', 'BTCUSDT', '4h')
    
    # 2024ë…„ë¶€í„° 2025ë…„ê¹Œì§€ì˜ CSV íŒŒì¼ë“¤ ì°¾ê¸°
    csv_files = []
    for year in [2024, 2025]:
        csv_pattern = f'BTCUSDT_4h_{year}.csv'
        year_files = glob.glob(os.path.join(data_dir, csv_pattern))
        csv_files.extend(year_files)
    
    if not csv_files:
        print(f"âŒ CSV íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        print(f"ğŸ“ ë°ì´í„° ë””ë ‰í† ë¦¬: {data_dir}")
        print("ë¨¼ì € í•„ìš”í•œ ë°ì´í„°ë¥¼ ë‹¤ìš´ë¡œë“œí•˜ì„¸ìš”.")
        return
    
    # ëª¨ë“  CSV íŒŒì¼ì„ í•˜ë‚˜ë¡œ í•©ì¹˜ê¸°
    all_data = []
    for csv_file in sorted(csv_files):
        try:
            df = pd.read_csv(csv_file, index_col='datetime', parse_dates=True)
            all_data.append(df)
            print(f"âœ… {os.path.basename(csv_file)} ë¡œë“œ ì™„ë£Œ: {len(df)}ê°œ ìº”ë“¤")
        except Exception as e:
            print(f"âŒ {csv_file} ë¡œë“œ ì‹¤íŒ¨: {e}")
    
    if not all_data:
        print("ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        return
    
    # ëª¨ë“  ë°ì´í„° í•©ì¹˜ê¸°
    df_4h = pd.concat(all_data, ignore_index=False)
    df_4h = df_4h.sort_index()  # ì‹œê°„ìˆœ ì •ë ¬
    
    print(f"âœ… ì „ì²´ ë°ì´í„° ë¡œë“œ ì™„ë£Œ: {len(df_4h)}ê°œ ìº”ë“¤")
    print(f"ê¸°ê°„: {df_4h.index[0]} ~ {df_4h.index[-1]}")
    
    # ì›”ê°„ë³„ ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥
    monthly_backtest_results = []
    
    # ê° ì›”ë³„ë¡œ ë°±í…ŒìŠ¤íŠ¸ ì§„í–‰ (ì—°ì†ì„± ìœ ì§€)
    current_capital = initial_capital  # ì²« ë‹¬ì€ 10000ìœ¼ë¡œ ì‹œì‘
    for month_key, params in monthly_parameters.items():
        # ìœ íš¨í•œ ì›”ë³„ í‚¤ì¸ì§€ í™•ì¸ (YYYY_MM í˜•ì‹)
        if not month_key.replace('_', '').isdigit() or month_key.count('_') != 1:
            print(f"âš ï¸ ìœ íš¨í•˜ì§€ ì•Šì€ í‚¤ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤: {month_key}")
            continue
            
        try:
            year, month = month_key.split('_')
            year = int(year)
            month = int(month)
        except ValueError:
            print(f"âš ï¸ í‚¤ í˜•ì‹ ì˜¤ë¥˜ë¥¼ ê±´ë„ˆëœë‹ˆë‹¤: {month_key}")
            continue
        
        # í•´ë‹¹ ì›”ì˜ ë°ì´í„° ì¶”ì¶œ (ì •í™•íˆ 1ê°œì›”ë§Œ)
        month_start_date = datetime.datetime(year, month, 1)
        if month == 12:
            month_end_date = datetime.datetime(year + 1, 1, 1) - datetime.timedelta(seconds=1)
        else:
            month_end_date = datetime.datetime(year, month + 1, 1) - datetime.timedelta(seconds=1)
        
        month_df = df_4h[(df_4h.index >= month_start_date) & (df_4h.index < month_end_date)]
        
        if len(month_df) < 10:  # ìµœì†Œ 10ê°œ ìº”ë“¤ ì´ìƒ
            print(f"âš ï¸ {year}ë…„ {month:02d}ì›” ë°ì´í„°ê°€ ë¶€ì¡±í•˜ì—¬ ê±´ë„ˆëœë‹ˆë‹¤. ({len(month_df)}ê°œ ìº”ë“¤)")
            continue
        
        # íŒŒë¼ë¯¸í„° ì¶”ì¶œ
        long_params = params.get('long_strategy', {})
        short_params = params.get('short_strategy', {})
        
        if not long_params or not short_params:
            print(f"âš ï¸ {year}ë…„ {month:02d}ì›” íŒŒë¼ë¯¸í„°ê°€ ë¶€ì¡±í•˜ì—¬ ê±´ë„ˆëœë‹ˆë‹¤.")
            continue
        
        ma1_long = long_params['ma1']
        ma2_long = long_params['ma2']
        trend_params_long = long_params.get('trend_params', {})
        
        ma1_short = short_params['ma1']
        ma2_short = short_params['ma2']
        trend_params_short = short_params.get('trend_params', {})
        
        print(f"\n{'='*60}")
        # ì§„í–‰ë¥ ì„ í˜„ì¬ ì²˜ë¦¬ ì¤‘ì¸ ì›”ì˜ ì¸ë±ìŠ¤ë¡œ ê³„ì‚°
        current_month_index = list(monthly_parameters.keys()).index(month_key) + 1
        print(f"ì§„í–‰ë¥ : {current_month_index}/{len(monthly_parameters)} ì›”")
        print(f"ê¸°ê°„: {year}ë…„ {month:02d}ì›”")
        print(f"ë¡± ì „ëµ: MA1={ma1_long}, MA2={ma2_long}, ì¶”ì„¸={trend_params_long}")
        print(f"ìˆ ì „ëµ: MA1={ma1_short}, MA2={ma2_short}, ì¶”ì„¸={trend_params_short}")
        
        # í˜„ì¬ ìë³¸ì„ ë¡±/ìˆ 50:50ìœ¼ë¡œ ë¶„í• 
        long_capital = current_capital * 0.5
        short_capital = current_capital * 0.5
        
        print(f"í˜„ì¬ ìë³¸: {current_capital:.2f} USDT")
        print(f"ì „ëµ: ë¡± 50% + ìˆ 50% (MA + ì¶”ì„¸)")
        print(f"ë¡± ìë³¸: {long_capital:.2f} USDT")
        print(f"ìˆ ìë³¸: {short_capital:.2f} USDT")
        print()
        
        # ë¡± ì „ëµ ë°±í…ŒìŠ¤íŠ¸
        print("ğŸ“ˆ ë¡± ì „ëµ ë°±í…ŒìŠ¤íŠ¸ (ìë³¸: {:.2f} USDT)".format(long_capital))
        long_result = backtest_strategy(month_df, ma1_long, ma2_long, long_capital, leverage, 
                                       fee=0.001, strategy_type='LONG', trend_params=trend_params_long, use_trend=True)
        
        # ìˆ ì „ëµ ë°±í…ŒìŠ¤íŠ¸  
        print("ğŸ“‰ ìˆ ì „ëµ ë°±í…ŒìŠ¤íŠ¸ (ìë³¸: {:.2f} USDT)".format(short_capital))
        short_result = backtest_strategy(month_df, ma1_short, ma2_short, short_capital, leverage, 
                                        fee=0.001, strategy_type='SHORT', trend_params=trend_params_short, use_trend=True)
        
        if long_result and short_result:
            # ë¡±/ìˆ ê²°ê³¼ í•©ì‚°
            combined_equity_curve = []
            combined_trades = []
            
            # ì›”ë³„ ë°ì´í„°ì—ì„œ ê°€ê²© ì •ë³´ ì¶”ì¶œ
            month_prices = month_df['close'].to_dict()
            
            # ì‹œê°„ìˆœìœ¼ë¡œ ì •ë ¬ëœ ëª¨ë“  ì‹œê°„ëŒ€ ìƒì„± (ì¤‘ë³µ ì œê±°)
            all_times = sorted(set(month_df.index))
            
            # ê° ì‹œê°„ëŒ€ë³„ë¡œ ë¡±/ìˆ ìì‚° ê³„ì‚°
            for current_time in all_times:
                current_price = month_prices.get(current_time, 0)
                
                # ë¡± ì „ëµ ìì‚° ê³„ì‚°
                long_equity = long_capital
                long_entry_price = 0
                long_exit_price = 0
                if long_result['equity_curve']:
                    # í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ë¡± ìì‚° ì°¾ê¸°
                    long_point = next((p for p in long_result['equity_curve'] if p['time'] == current_time), None)
                    if long_point:
                        long_equity = long_point['equity']
                
                # ìˆ ì „ëµ ìì‚° ê³„ì‚°
                short_equity = short_capital
                short_entry_price = 0
                short_exit_price = 0
                if short_result['equity_curve']:
                    # í•´ë‹¹ ì‹œê°„ëŒ€ì˜ ìˆ ìì‚° ì°¾ê¸°
                    short_point = next((p for p in short_result['equity_curve'] if p['time'] == current_time), None)
                    if short_point:
                        short_equity = short_point['equity']
                
                # í˜„ì¬ ì‹œê°„ëŒ€ì˜ ë¡±/ìˆ ì§„ì…ê°€ì™€ ì²­ì‚°ê°€ ê³„ì‚°
                if long_result['trades']:
                    # í˜„ì¬ ì‹œê°„ ì´ì „ì˜ ê°€ì¥ ìµœê·¼ ë¡± ê±°ë˜ ì°¾ê¸°
                    long_trades_before = [t for t in long_result['trades'] if t['entry_time'] <= current_time]
                    if long_trades_before:
                        latest_long_trade = max(long_trades_before, key=lambda x: x['entry_time'])
                        long_entry_price = latest_long_trade['entry_price']
                        
                        # í˜„ì¬ ì‹œê°„ì´ ì§„ì… ì‹œê°„ê³¼ ì²­ì‚° ì‹œê°„ ì‚¬ì´ì— ìˆëŠ”ì§€ í™•ì¸
                        if latest_long_trade['entry_time'] <= current_time < latest_long_trade['exit_time']:
                            # ì•„ì§ ì²­ì‚°ë˜ì§€ ì•Šì€ ê²½ìš° (ì§„ì… í›„, ì²­ì‚° ì „)
                            long_exit_price = current_price
                        else:
                            # ì´ë¯¸ ì²­ì‚°ëœ ê²½ìš°
                            long_exit_price = latest_long_trade['exit_price']
                    else:
                        long_entry_price = 0
                        long_exit_price = 0
                else:
                    long_entry_price = 0
                    long_exit_price = 0
                
                if short_result['trades']:
                    # í˜„ì¬ ì‹œê°„ ì´ì „ì˜ ê°€ì¥ ìµœê·¼ ìˆ ê±°ë˜ ì°¾ê¸°
                    short_trades_before = [t for t in short_result['trades'] if t['entry_time'] <= current_time]
                    if short_trades_before:
                        latest_short_trade = max(short_trades_before, key=lambda x: x['entry_time'])
                        short_entry_price = latest_short_trade['entry_price']
                        
                        # í˜„ì¬ ì‹œê°„ì´ ì§„ì… ì‹œê°„ê³¼ ì²­ì‚° ì‹œê°„ ì‚¬ì´ì— ìˆëŠ”ì§€ í™•ì¸
                        if latest_short_trade['entry_time'] <= current_time < latest_short_trade['exit_time']:
                            # ì•„ì§ ì²­ì‚°ë˜ì§€ ì•Šì€ ê²½ìš° (ì§„ì… í›„, ì²­ì‚° ì „)
                            short_exit_price = current_price
                        else:
                            # ì´ë¯¸ ì²­ì‚°ëœ ê²½ìš°
                            short_exit_price = latest_short_trade['exit_price']
                    else:
                        short_entry_price = 0
                        short_exit_price = 0
                else:
                    short_entry_price = 0
                    short_exit_price = 0
                
                # pnl_displayì— ì§„ì…ê°€ì™€ ë§¤ìˆ˜/ì²­ì‚° ì •ë³´ ì¶”ê°€
                if long_entry_price > 0:
                    if long_exit_price > 0 and long_exit_price != long_entry_price:
                        # ì´ë¯¸ ì²­ì‚°ëœ ê²½ìš°
                        if current_time >= latest_long_trade['exit_time']:
                            # ì²­ì‚° ì§í›„ì—ëŠ” ìˆ˜ìµë¥ ê³¼ ìˆ˜ìµê¸ˆ í‘œì‹œ
                            long_pnl = (long_exit_price - long_entry_price) / long_entry_price * 100
                            long_profit = (long_exit_price - long_entry_price) * leverage * (long_capital / long_entry_price)
                            long_info = f"ë¡±ì²­ì‚°:{long_pnl:+.1f}%({long_profit:+.0f})"
                        else:
                            # ì•„ì§ ì²­ì‚°ë˜ì§€ ì•Šì€ ê²½ìš°
                            long_info = f"ë¡±ì§„ì…:{long_entry_price:.0f}â†’{long_exit_price:.0f}"
                    else:
                        long_info = f"ë¡±ì§„ì…:{long_entry_price:.0f}"
                else:
                    long_info = "ë¡±:ëŒ€ê¸°"
                
                if short_entry_price > 0:
                    if short_exit_price > 0 and short_exit_price != short_entry_price:
                        # ì´ë¯¸ ì²­ì‚°ëœ ê²½ìš°
                        if current_time >= latest_short_trade['exit_time']:
                            # ì²­ì‚° ì§í›„ì—ëŠ” ìˆ˜ìµë¥ ê³¼ ìˆ˜ìµê¸ˆ í‘œì‹œ
                            short_pnl = (short_entry_price - short_exit_price) / short_entry_price * 100
                            short_profit = (short_entry_price - short_exit_price) * leverage * (short_capital / short_entry_price)
                            short_info = f"ìˆì²­ì‚°:{short_pnl:+.1f}%({short_profit:+.0f})"
                        else:
                            # ì•„ì§ ì²­ì‚°ë˜ì§€ ì•Šì€ ê²½ìš°
                            short_info = f"ìˆì§„ì…:{short_entry_price:.0f}â†’{short_exit_price:.0f}"
                    else:
                        short_info = f"ìˆì§„ì…:{short_entry_price:.0f}"
                else:
                    short_info = "ìˆ:ëŒ€ê¸°"
                
                # í•©ì‚° ìì‚° ê³„ì‚°
                combined_equity = long_equity + short_equity
                
                # pnl_display ìƒì„±
                pnl_display = f"{long_info} | {short_info} | í•©ì‚°:{combined_equity:.0f}"
                
                combined_equity_curve.append({
                    'time': current_time,
                    'equity': combined_equity,
                    'long_equity': long_equity,
                    'short_equity': short_equity,
                    'price': current_price,
                    'pnl_display': pnl_display,
                    'long_entry_price': long_entry_price,
                    'long_exit_price': long_exit_price,
                    'short_entry_price': short_entry_price,
                    'short_exit_price': short_exit_price
                })
            
            # í•©ì‚° ê±°ë˜ ë‚´ì—­
            combined_trades = long_result['trades'] + short_result['trades']
            combined_trades.sort(key=lambda x: x['entry_time'])
            
            # ì›”ë³„ ê²°ê³¼ ê³„ì‚°
            month_start_equity = combined_equity_curve[0]['equity'] if combined_equity_curve else current_capital
            month_end_equity = combined_equity_curve[-1]['equity'] if combined_equity_curve else current_capital
            month_return = (month_end_equity - month_start_equity) / month_start_equity * 100
            
            # MDD ê³„ì‚°
            peak = month_start_equity
            month_mdd = 0
            for point in combined_equity_curve:
                if point['equity'] > peak:
                    peak = point['equity']
                drawdown = (peak - point['equity']) / peak * 100
                if drawdown > month_mdd:
                    month_mdd = drawdown
            
            # ìŠ¹ë¥  ê³„ì‚°
            if combined_trades:
                winning_trades = [t for t in combined_trades if t['pnl'] > 0]
                win_rate = len(winning_trades) / len(combined_trades) * 100
            else:
                win_rate = 0
            
            # ê°€ê²© ë³€í™”
            month_start_price = month_df['close'].iloc[0]
            month_end_price = month_df['close'].iloc[-1]
            price_change = (month_end_price - month_start_price) / month_start_price * 100
            
            # ë¡± ì „ëµ í‰ê·  ì§„ì…ê°€
            if long_result['trades']:
                long_avg_entry = sum(t['entry_price'] for t in long_result['trades']) / len(long_result['trades'])
                print(f"  ë¡± í‰ê·  ì§„ì…ê°€: {long_avg_entry:.0f} USDT")
            
            print(f"  ê°€ê²© ë³€í™”: {month_start_price:.0f} â†’ {month_end_price:.0f} ({price_change:+.2f}%)")
            print(f"  ìŠ¹ë¥ : {win_rate:.1f}%")
            
            # ë‹¤ìŒ ë‹¬ ì´ˆê¸° ìë³¸ ì—…ë°ì´íŠ¸
            current_capital = month_end_equity
            print(f"  ë‹¤ìŒ ë‹¬ ì´ˆê¸° ìë³¸: {current_capital:.2f} USDT")
            
            # ì›”ë³„ ê²°ê³¼ ì €ì¥
            monthly_backtest_results.append({
                'month': month_key,
                'year': year,
                'month_num': month,
                'long_return': long_result['total_return'],
                'short_return': short_result['total_return'],
                'combined_return': month_return,
                'long_mdd': long_result['mdd'],
                'short_mdd': short_result['mdd'],
                'combined_mdd': month_mdd,
                'long_trades': long_result['trade_count'],
                'short_trades': short_result['trade_count'],
                'combined_trades': len(combined_trades),
                'win_rate': win_rate,
                'start_capital': month_start_equity,
                'end_capital': month_end_equity,
                'start_price': month_start_price,
                'end_price': month_end_price,
                'equity_curve': combined_equity_curve,
                'trades': combined_trades
            })
            
        else:
            print("ë°±í…ŒìŠ¤íŠ¸ ì‹¤íŒ¨")
            # ì‹¤íŒ¨í•œ ê²½ìš°ì—ë„ ë‹¤ìŒ ë‹¬ ì´ˆê¸° ìë³¸ ìœ ì§€
            monthly_backtest_results.append({
                'month': month_key,
                'year': year,
                'month_num': month,
                'long_return': 0,
                'short_return': 0,
                'combined_return': 0,
                'long_mdd': 0,
                'short_mdd': 0,
                'combined_mdd': 0,
                'long_trades': 0,
                'short_trades': 0,
                'combined_trades': 0,
                'win_rate': 0,
                'start_capital': current_capital,
                'end_capital': current_capital,
                'start_price': month_df['close'].iloc[0] if len(month_df) > 0 else 0,
                'end_price': month_df['close'].iloc[-1] if len(month_df) > 0 else 0,
                'equity_curve': [],
                'trades': []
            })
    
    print("\n============================================================")
    print("ì›”ê°„ ë°±í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")
    
    # ì „ì²´ ì„±ê³¼ ìš”ì•½
    if monthly_backtest_results:
        total_months = len(monthly_backtest_results)
        profitable_months = len([r for r in monthly_backtest_results if r['combined_return'] > 0])
        total_return = (current_capital - initial_capital) / initial_capital * 100
        avg_monthly_return = total_return / total_months
        
        # ì „ì²´ MDD ê³„ì‚°
        all_equity_points = []
        for result in monthly_backtest_results:
            all_equity_points.extend(result['equity_curve'])
        
        all_equity_points.sort(key=lambda x: x['time'])
        
        peak = initial_capital
        total_mdd = 0
        for point in all_equity_points:
            if point['equity'] > peak:
                peak = point['equity']
            drawdown = (peak - point['equity']) / peak * 100
            if drawdown > total_mdd:
                total_mdd = drawdown
        
        print("\n=== ì „ì²´ ì„±ê³¼ ìš”ì•½ ===")
        print(f"ì‚¬ìš© ì „ëµ: ë¡± 50% + ìˆ 50% (MA + ì¶”ì„¸)")
        print(f"ì´ ê°œì›”: {total_months}ê°œì›”")
        print(f"ìˆ˜ìµ ê°œì›”: {profitable_months}ê°œì›” ({profitable_months/total_months*100:.1f}%)")
        print(f"ì´ ìˆ˜ìµë¥ : {total_return:.2f}%")
        print(f"í‰ê·  ì›”ê°„ ìˆ˜ìµë¥ : {avg_monthly_return:.2f}%")
        print(f"ìµœëŒ€ MDD: {total_mdd:.2f}%")
        
        # ì „ëµë³„ ì„±ê³¼
        long_total_return = sum(r['long_return'] for r in monthly_backtest_results)
        short_total_return = sum(r['short_return'] for r in monthly_backtest_results)
        long_avg_return = long_total_return / total_months
        short_avg_return = short_total_return / total_months
        
        print("\n=== ì „ëµë³„ ì„±ê³¼ ===")
        print(f"ë¡± ì „ëµ: ì´ ìˆ˜ìµë¥ ={long_total_return:.2f}%, í‰ê· ={long_avg_return:.2f}%")
        print(f"ìˆ ì „ëµ: ì´ ìˆ˜ìµë¥ ={short_total_return:.2f}%, í‰ê· ={short_avg_return:.2f}%")
        
        # ì›”ê°„ë³„ íŒŒë¼ë¯¸í„° ë³€í™”
        print("\n=== ì›”ê°„ë³„ íŒŒë¼ë¯¸í„° ë³€í™” ===")
        for result in monthly_backtest_results:
            month_key = result['month']
            year = result['year']
            month = result['month_num']
            long_return = result['long_return']
            short_return = result['short_return']
            combined_return = result['combined_return']
            
            if month_key in monthly_parameters:
                params = monthly_parameters[month_key]
                long_params = params.get('long_strategy', {})
                short_params = params.get('short_strategy', {})
                
                ma1_long = long_params.get('ma1', 'N/A')
                ma2_long = long_params.get('ma2', 'N/A')
                ma1_short = short_params.get('ma1', 'N/A')
                ma2_short = short_params.get('ma2', 'N/A')
                
                print(f"{year}-{month:02d}: ë¡±(MA1={ma1_long}, MA2={ma2_long}), ìˆ(MA1={ma1_short}, MA2={ma2_short}), í•©ì‚°={combined_return:.2f}%")
        
        # ê²°ê³¼ ì €ì¥
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
        result_filename = f"MA_Trend_Backtest_LongShort_Result_BTC_USDT_{timestamp}.json"
        result_path = os.path.join(script_dir, 'logs', result_filename)
        
        # ë¡œê·¸ ë””ë ‰í† ë¦¬ ìƒì„±
        os.makedirs(os.path.dirname(result_path), exist_ok=True)
        
        # ê²°ê³¼ ë°ì´í„° êµ¬ì„±
        result_data = {
            'backtest_period': {
                'start_date': monthly_backtest_results[0]['start_price'],
                'end_date': monthly_backtest_results[-1]['end_price'],
                'total_months': total_months
            },
            'performance_summary': {
                'total_return': total_return,
                'avg_monthly_return': avg_monthly_return,
                'profitable_months': profitable_months,
                'total_mdd': total_mdd,
                'final_capital': current_capital
            },
            'strategy_performance': {
                'long_total_return': long_total_return,
                'short_total_return': short_total_return,
                'long_avg_return': long_avg_return,
                'short_avg_return': short_avg_return
            },
            'monthly_results': monthly_backtest_results,
            'all_equity_curve': all_equity_points
        }
        
        # JSON íŒŒì¼ë¡œ ì €ì¥
        with open(result_path, 'w', encoding='utf-8') as f:
            json.dump(result_data, f, ensure_ascii=False, indent=2, default=str)
        
        print(f"\nìµœì¢… ê²°ê³¼ê°€ {result_path}ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
        
        # ê·¸ë˜í”„ ìƒì„±
        print("\nì „ì²´ ê¸°ê°„ ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê·¸ë˜í”„ ìƒì„± ì¤‘...")
        try:
            # ì „ì²´ ë°ì´í„° ì¤€ë¹„
            all_times = [point['time'] for point in all_equity_points]
            all_equities = [point['equity'] for point in all_equity_points]
            all_prices = [point['price'] for point in all_equity_points]
            
            # ë¡±/ìˆ ê°œë³„ ìì‚° ì¶”ì¶œ
            long_equities = []
            short_equities = []
            for result in monthly_backtest_results:
                if result['equity_curve']:
                    for point in result['equity_curve']:
                        long_equities.append(point.get('long_equity', 0))
                        short_equities.append(point.get('short_equity', 0))
            
            # ê±°ë˜ ë‚´ì—­ ì¶”ì¶œ
            all_trades = []
            for result in monthly_backtest_results:
                all_trades.extend(result['trades'])
            
            # MA ë°ì´í„° ì¤€ë¹„ (4ì‹œê°„ ë°ì´í„°ì—ì„œ)
            ma_data = {}
            for month_key in monthly_parameters:
                if month_key in monthly_parameters:
                    params = monthly_parameters[month_key]
                    long_params = params.get('long_strategy', {})
                    short_params = params.get('short_strategy', {})
                    
                    # í•´ë‹¹ ì›”ì˜ ë°ì´í„° ì°¾ê¸°
                    for result in monthly_backtest_results:
                        if result['month'] == month_key and result['equity_curve']:
                            month_df = df_4h[(df_4h.index >= result['equity_curve'][0]['time']) & 
                                           (df_4h.index <= result['equity_curve'][-1]['time'])]
                            
                            if len(month_df) > 0:
                                ma1_long = long_params.get('ma1', 20)
                                ma2_long = long_params.get('ma2', 50)
                                ma1_short = short_params.get('ma1', 20)
                                ma2_short = short_params.get('ma2', 50)
                                
                                month_df[f'ma_{ma1_long}_long'] = month_df['close'].rolling(ma1_long).mean()
                                month_df[f'ma_{ma2_long}_long'] = month_df['close'].rolling(ma2_long).mean()
                                month_df[f'ma_{ma1_short}_short'] = month_df['close'].rolling(ma1_short).mean()
                                month_df[f'ma_{ma2_short}_short'] = month_df['close'].rolling(ma2_short).mean()
                                
                                ma_data[month_key] = month_df
                            break
            
            # 4ê°œ ì„œë¸Œí”Œë¡¯ ìƒì„±
            fig, axes = plt.subplots(4, 1, figsize=(20, 16))
            
            # 1. ë¹„íŠ¸ì½”ì¸ 4ì‹œê°„ ë°ì´í„° + ê±°ë˜ë‚´ì—­ + MA
            ax1 = axes[0]
            
            # ì „ì²´ 4ì‹œê°„ ë°ì´í„° í”Œë¡¯
            df_4h_filtered = df_4h[(df_4h.index >= all_times[0]) & (df_4h.index <= all_times[-1])]
            ax1.plot(df_4h_filtered.index, df_4h_filtered['close'], 'k-', linewidth=1, alpha=0.8, label='BTC 4H')
            
            # MA ì„ ë“¤ í”Œë¡¯ (ì›”ë³„ë¡œ ë‹¤ë¥¸ ìƒ‰ìƒ)
            colors = ['red', 'blue', 'green', 'orange', 'purple', 'brown', 'pink', 'gray']
            for i, (month_key, month_df) in enumerate(ma_data.items()):
                if len(month_df) > 0:
                    color = colors[i % len(colors)]
                    ma1_long = monthly_parameters[month_key]['long_strategy'].get('ma1', 20)
                    ma2_long = monthly_parameters[month_key]['long_strategy'].get('ma2', 50)
                    
                    ax1.plot(month_df.index, month_df[f'ma_{ma1_long}_long'], 
                            color=color, linewidth=1, alpha=0.6, linestyle='--')
                    ax1.plot(month_df.index, month_df[f'ma_{ma2_long}_long'], 
                            color=color, linewidth=1, alpha=0.6, linestyle=':')
            
            # ê±°ë˜ ë‚´ì—­ í™”ì‚´í‘œ í‘œì‹œ
            for trade in all_trades:
                if 'entry_time' in trade and 'exit_time' in trade:
                    # ì§„ì… ì§€ì  (ë…¹ìƒ‰ í™”ì‚´í‘œ ìœ„)
                    ax1.scatter(trade['entry_time'], trade['entry_price'], 
                               color='green', marker='^', s=100, alpha=0.8, zorder=5)
                    # ì²­ì‚° ì§€ì  (ë¹¨ê°„ìƒ‰ í™”ì‚´í‘œ ì•„ë˜)
                    ax1.scatter(trade['exit_time'], trade['exit_price'], 
                               color='red', marker='v', s=100, alpha=0.8, zorder=5)
                    
                    # ì§„ì…-ì²­ì‚° ì„  ì—°ê²°
                    ax1.plot([trade['entry_time'], trade['exit_time']], 
                            [trade['entry_price'], trade['exit_price']], 
                            'k-', alpha=0.5, linewidth=1)
            
            ax1.set_title('BTC 4ì‹œê°„ ë°ì´í„° + ê±°ë˜ë‚´ì—­ + MA ì´ë™í‰ê· ì„ ', fontsize=14, fontweight='bold')
            ax1.set_ylabel('ê°€ê²© (USDT)', fontsize=12)
            ax1.legend(['BTC 4H', 'MA1 (ë¡±)', 'MA2 (ë¡±)'], loc='upper left')
            ax1.grid(True, alpha=0.3)
            
            # 2. ê±°ë˜ë‚´ì—­ ìƒì„¸
            ax2 = axes[1]
            
            # ê±°ë˜ë³„ ìˆ˜ìµë¥  í‘œì‹œ
            trade_times = [trade['entry_time'] for trade in all_trades]
            trade_returns = [trade['pnl'] * 100 for trade in all_trades]  # í¼ì„¼íŠ¸ë¡œ ë³€í™˜
            
            colors = ['green' if ret > 0 else 'red' for ret in trade_returns]
            bars = ax2.bar(range(len(trade_times)), trade_returns, color=colors, alpha=0.7)
            
            # ìˆ˜ìµë¥  ê°’ í‘œì‹œ
            for i, (bar, ret) in enumerate(zip(bars, trade_returns)):
                height = bar.get_height()
                ax2.text(bar.get_x() + bar.get_width()/2., height + (0.1 if height > 0 else -0.1),
                        f'{ret:.1f}%', ha='center', va='bottom' if height > 0 else 'top')
            
            ax2.set_title('ê±°ë˜ë³„ ìˆ˜ìµë¥ ', fontsize=14, fontweight='bold')
            ax2.set_ylabel('ìˆ˜ìµë¥  (%)', fontsize=12)
            ax2.set_xlabel('ê±°ë˜ ìˆœì„œ', fontsize=12)
            ax2.axhline(y=0, color='black', linestyle='-', alpha=0.5)
            ax2.grid(True, alpha=0.3)
            
            # 3. ìì‚°ì¦ê°í˜„í™©
            ax3 = axes[2]
            
            # ë¡±/ìˆ/í•©ì‚° ìì‚° ê³¡ì„ 
            ax3.plot(all_times, all_equities, 'b-', linewidth=2, label='í•©ì‚° ìì‚°', alpha=0.8)
            
            # ë¡±/ìˆ ê°œë³„ ìì‚° (ì›”ë³„ë¡œ êµ¬ë¶„)
            if long_equities and short_equities:
                ax3.plot(all_times[:len(long_equities)], long_equities, 'g-', linewidth=1, 
                        label='ë¡± ìì‚°', alpha=0.6)
                ax3.plot(all_times[:len(short_equities)], short_equities, 'r-', linewidth=1, 
                        label='ìˆ ìì‚°', alpha=0.6)
            
            ax3.axhline(y=initial_capital, color='black', linestyle='--', alpha=0.7, label='ì´ˆê¸° ìë³¸')
            ax3.set_title('ìì‚°ì¦ê°í˜„í™© (ë¡±/ìˆ/í•©ì‚°)', fontsize=14, fontweight='bold')
            ax3.set_ylabel('ìì‚° (USDT)', fontsize=12)
            ax3.legend()
            ax3.grid(True, alpha=0.3)
            
            # 4. MDD í˜„í™©
            ax4 = axes[3]
            
            # MDD ê³„ì‚° ë° í”Œë¡¯
            peak = initial_capital
            mdd_values = []
            mdd_times = []
            
            for i, equity in enumerate(all_equities):
                if equity > peak:
                    peak = equity
                drawdown = (peak - equity) / peak * 100
                mdd_values.append(drawdown)
                mdd_times.append(all_times[i])
            
            ax4.fill_between(mdd_times, mdd_values, 0, alpha=0.3, color='red', label='MDD')
            ax4.plot(mdd_times, mdd_values, 'r-', linewidth=1, alpha=0.8)
            
            # ìµœëŒ€ MDD ì§€ì  í‘œì‹œ
            max_mdd_idx = np.argmax(mdd_values)
            max_mdd = mdd_values[max_mdd_idx]
            max_mdd_time = mdd_times[max_mdd_idx]
            
            ax4.scatter(max_mdd_time, max_mdd, color='darkred', s=100, zorder=5, 
                       label=f'ìµœëŒ€ MDD: {max_mdd:.2f}%')
            ax4.text(max_mdd_time, max_mdd + 0.5, f'{max_mdd:.2f}%', 
                     ha='center', va='bottom', fontweight='bold')
            
            ax4.set_title('MDD (Maximum Drawdown) í˜„í™©', fontsize=14, fontweight='bold')
            ax4.set_ylabel('MDD (%)', fontsize=12)
            ax4.set_xlabel('ì‹œê°„', fontsize=12)
            ax4.legend()
            ax4.grid(True, alpha=0.3)
            ax4.invert_yaxis()  # MDDëŠ” ìœ„ì—ì„œ ì•„ë˜ë¡œ í‘œì‹œ
            
            # xì¶• ë‚ ì§œ í¬ë§· (ëª¨ë“  ì„œë¸Œí”Œë¡¯ì— ì ìš©)
            for ax in axes:
                ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
                ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
                ax.tick_params(axis='x', rotation=45)
            
            plt.tight_layout()
            
            # ê·¸ë˜í”„ ì €ì¥
            graph_filename = f"MA_Trend_Backtest_LongShort_Graph_BTC_USDT_{timestamp}.png"
            graph_path = os.path.join(script_dir, 'logs', graph_filename)
            plt.savefig(graph_path, dpi=300, bbox_inches='tight')
            plt.close()
            
            print(f"ğŸ“Š ê°œì„ ëœ ê·¸ë˜í”„ê°€ {graph_path}ì— ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.")
            
        except Exception as e:
            print(f"ê·¸ë˜í”„ ìƒì„± ì‹¤íŒ¨: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    main()
