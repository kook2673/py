"""
- 현재 AI 모델 기반으로 지표 및 파라미터 값 자동 탐색 및 익/손절등도 모두 자동화를 100% 했습니다.
- 자동매매 참고용으로 AI 모델 및 백테스트 중요 카테고리 및 함수, 주요 역할등에 대해서 공유 드립니다.
- 예측모델은 XGBoost 모델 사용합니다.
- 4시간봉 사용
- 추세추종, 모멘텀, 변동성, 거래량, 일목균형, 펀딩비, 프리미엄 인덱스, 거시경제 vix, CDV, 비트코인 특화  ADX, SAR 및 펀딩비, 거래량, 반감기등 피쳐등 함수를 정의했고, AI가 조합해서 약 65개 정도 피쳐를 생성합니다.
- 65개 중에서 가장 사용 빈도가 높은 지표등을 60%만 1단계로 추려서 순위화 하고, 선택된 60% 지표(예 :  40개)에 대해서 함수 로직에 의해서 만약 max feature 15 케이스이면 다시 40개 지표에서 재계산을 통해서 15개를 최종 선택하고, 확정된 지표를 모델 파일로 저장합니다. 백테스트 진행시 최종 선택된 모델을 불러와서 4시간 캔들마다 포지션 진입 여부를 판단합니다.
- Gemini or grok에게 위에 올려준 화두만 던져주면 관련 로직을 생성하여 제공해 줍니다. 저도 그런식으로 한개 한개 내용을 보완하면서 현재 버전까지 만들었습니다. 5개월 전에 코딩에 대한 지식이 1%도 없이 시작했고 다른분도 GPT와 시간을 오래 보내시면 가능하다고 생각합니다.
"""

"""
=== 머신러닝 파이프라인 7단계 구조 ===

1. 데이터 준비 및 전처리 (Data Preparation and Preprocessing)
   - create_mtf_base_df: 데이터셋의 기초를 구축
     * OHLCV 데이터 로드 (예: 4시간 캔들스틱)
     * 상위 시간프레임(예: 1일)에서 핵심 지표(RSI, MACD) 계산
     * 하위 시간프레임 데이터와 결합 (MTF 분석)
     * 버전 설정(v2, v3, v4)에 따라 외부 데이터(펀딩레이트, 프리미엄 인덱스, VIX) 통합
   
   - clean_df: 데이터 품질 보장
     * 무한값(inf) 제거
     * 통계적 방법(IQR)을 사용한 이상치 식별 및 제거
     * 중복된 시간 인덱스 삭제
     * 지정된 방법(평균, 중앙값)으로 결측값(NaN) 채우기

2. 라벨링 (정답지 생성) (Labeling - Ground Truth Generation)
   - create_triple_labels_adaptive: AI 모델의 학습 타겟(라벨) 생성 핵심 함수
     * BTC 특화 드라이버(ATR, 반감기, 펀딩레이트 급등)를 통합하여 동적 TP/SL 라인 계산
     * 고정값 대신 동적 계산으로 정확도 향상
     * TP에 먼저 도달하면 1(성공), SL에 먼저 도달하면 -1(실패)로 라벨링
   
   - @jit_find_first_barrier_hit: 라벨링 속도 100배 이상 가속화
     * Numba JIT 컴파일러를 사용하여 가장 계산 집약적인 루프 가속화
     * 수백만 행의 복잡한 동적 라벨링을 몇 분 내에 처리 가능

3. 피처 엔지니어링 (Feature Engineering)
   - build_features: 65개 이상의 시장 분석 지표(피처)를 생성하는 종합 팩토리
     * add_*_features 함수들을 순차적으로 호출하여 기술적 지표 생성
     * 트렌드, 모멘텀, 변동성, 거래량 등 카테고리별 지표 생성
     * 시장 변동성에 따라 지표 계산 기간을 동적 조정 (EMA, RSI 등)
     * 버전 설정에 따라 오더플로우(v3) 및 거시경제(v4) 피처 추가

4. 최적화 (Optuna) (Optimization - Optuna)
   - find_optimal_data_representation: 최적의 '데이터 표현'을 찾는 통합 최적화 함수
     * 피처 엔지니어링(예: EMA 기간)과 라벨링(예: TP/SL 비율) 파라미터를 동시 최적화
     * 수백 번의 테스트(Trials)를 통해 모델의 베이스라인 성능(Precision)을 최대화하는 최적 조합 탐색
   
   - dynamic_parameter_tuning_trainonly: XGBoost 모델 자체를 세밀하게 튜닝
     * 데이터 표현이 고정된 후 XGBoost 모델 하이퍼파라미터(학습률, 트리 깊이) 최적화
     * 최종 진입 임계값 최적화
     * 시계열 교차검증(TimeSeriesSplit)을 사용한 과적합 방지
     * 안정적이고 높은 성능(F1-Score)을 위한 모델 설정 탐색

5. 피처 선택 (Feature Selection)
   - SHAP + RFE 로직 (run_training_pipeline 내부): 수십 개의 후보 중에서 진정으로 중요한 피처 선택
     * 1단계 (SHAP): 훈련된 모델을 기반으로 피처 영향력 분석, 높은 중요도를 가진 상위 65% 후보로 빠르게 축소
     * 2단계 (RFE): 선택된 후보들에서 반복적으로 피처를 제거하여 최고 성능을 내는 최종 엘리트 피처 조합을 정확히 선택 (최대 max_features 개수까지)

6. 모델 학습 및 평가 (Model Training and Evaluation)
   - run_training_pipeline: 전체 훈련 과정을 감독하는 메인 오케스트레이터
     * 데이터 준비부터 데이터 표현 최적화, 모델 튜닝, 피처 선택, 최종 모델 훈련, OOS(Out-of-Sample) 성능 평가, 결과 저장까지 순차적으로 실행 및 관리
     * 롤링 윈도우 접근법을 사용하여 다양한 시장 상황에서의 일반화 성능 검증
   
   - rolling_window_split: 시간에 따른 훈련 및 검증 기간 이동
     * 과거 데이터로 훈련하고 미래 데이터로 테스트하는 과정을 여러 번 반복
     * 예: 2020-2022 훈련 → 2022 H1 검증; 2020 H2-2022 H2 훈련 → 2023 H1 검증
     * 모델의 견고성을 평가하기 위한 다중 검증

7. 유틸리티 및 안정성 (Utility and Stability)
   - validate_no_future_leakage: '타임머신' 버그(미래 데이터 누수) 방지
     * 피처 계산 중 미래 정보가 실수로 포함되었는지 통계적으로 검증
     * 이 검증을 통과해야 백테스트 결과의 신뢰성 보장
   
   - worker_function: 병렬 처리 처리
     * 멀티프로세싱 환경에서 run_training_pipeline 실행
     * 여러 심볼과 롱/숏 방향에 대해 동시에 훈련을 수행하여 전체 훈련 시간을 대폭 단축
"""

"""
=== 백테스팅 엔진 및 파이프라인 구조 ===

1. 핵심 백테스팅 엔진 (ProBacktester 클래스)
   - ProBacktester (클래스):
     * 주요 역할: 백테스트의 모든 과정을 총괄하는 중앙 컨트롤 타워.
     * 상세 설명: 포지션 진입/청산, 자본금 관리, 거래 기록 등 백테스팅의 모든 상태를 관리하고 실행하는 핵심 객체입니다.
   
   - run (메서드):
     * 주요 역할: 백테스트 시뮬레이션을 시작하고 실행하는 메인 엔진.
     * 상세 설명: ① 모델 로드 → ② AI 신호 생성 → ③ 과거 데이터를 한 캔들씩 순회하며 거래 로직 실행의 순서로 전체 시뮬레이션을 진행합니다.
   
   - _execute_initial_entry:
     * 주요 역할: 첫 포지션 진입을 담당하는 함수.
     * 상세 설명: AI 모델로부터 진입 신호가 오면, 초기 투자금, 레버리지, 재투자율 등을 고려하여 첫 진입 수량을 계산하고 포지션을 생성합니다. 익절(TP), 손절(SL), 추가매수(Scale-in) 가격을 최초로 설정합니다.
   
   - _check_and_execute_scale_in:
     * 주요 역할: 분할매수(추가 진입)를 실행하는 리스크 관리 함수.
     * 상세 설명: 포지션 진입 후 가격이 예상과 반대로 일정 수준(ATR 기반) 움직이면, 계획된 추가 진입을 실행합니다. 핵심 로직: 추가 진입 후 변경된 평균단가(평단)를 기준으로 손절(SL) 라인을 동적으로 재조정하여 리스크를 관리합니다.
   
   - _check_and_execute_exit:
     * 주요 역할: 다양한 조건에 따른 포지션 청산을 담당하는 함수.
     * 상세 설명: 매 캔들마다 ① 손절(Stop-Loss), ② 1차 익절(TP1), ③ 2차 익절(TP2), ④ 트레일링 스탑(Trailing Stop) 등 4가지 종료 조건을 모두 검사하고, 조건이 충족되면 포지션을 부분 또는 전체 청산합니다.
   
   - _close_position:
     * 주요 역할: 거래를 최종 마감하고 손익(PnL)을 정산하는 함수.
     * 상세 설명: 포지션이 완전히 종료될 때 호출됩니다. 최종 손익을 계산하여 계좌 자본금에 반영하고, 상세 거래 내역(진입/청산 가격, 수량, 사유 등)을 로그에 기록합니다.

2. 모델 로딩 및 환경 설정
   - _find_latest_model_prefix:
     * 주요 역할: 최신 AI 모델 파일을 자동으로 찾아내는 탐정 함수.
     * 상세 설명: 사용자가 파일 경로를 직접 지정할 필요 없이, 설정값(심볼, 시간봉, 버전, 피처 수)에 맞는 가장 최신 버전의 학습된 모델 파일을 폴더 내에서 자동으로 검색하고 식별합니다.
   
   - _load_artifacts_automatically:
     * 주요 역할: AI 모델과 모든 관련 파일을 로드하는 함수.
     * 상세 설명: _find_latest_model_prefix가 찾아낸 모델을 기반으로, 실제 예측에 필요한 모든 '아티팩트'(① XGBoost 모델, ② 데이터 스케일러, ③ 최종 선택된 피처 목록, ④ 동적 진입 임계값)를 메모리로 불러옵니다.

3. 피처 엔지니어링 (환경 동기화)
   - build_features (및 add_*_features 헬퍼 함수들):
     * 주요 역할: 학습 환경과 100% 동일한 피처를 생성하는 함수.
     * 상세 설명: 백테스트의 신뢰도를 보장하는 가장 중요한 부분입니다. 모델 학습(ai_model_unified_r8.py) 시 사용했던 피처 생성 로직을 그대로 가져와, 백테스트에서도 AI 모델이 완벽하게 동일한 데이터를 보고 예측하도록 보장합니다.

4. 성과 분석 및 리포팅
   - analyze_performance:
     * 주요 역할: 백테스트 결과를 종합 분석하여 최종 보고서를 생성하는 함수.
     * 상세 설명: 모든 거래가 끝난 후, 포트폴리오의 자산 변화 내역과 거래 로그를 바탕으로 총 수익률(%), 최대 낙폭(MDD), 샤프 지수, 승률(%) 등 핵심 성과 지표(KPI)를 계산하고 요약하여 출력합니다.

5. 최적화 및 병렬 처리
   - orchestrator_worker:
     * 주요 역할: 단일 ATR 조합에 대한 백테스트를 실행하는 '일꾼(Worker)' 함수.
     * 상세 설명: 테스트할 ATR 파라미터 조합(예: SL=2.0, TP1=1.5...)이 담긴 설정값 하나를 받아, 해당 조건으로 완전한 백테스트를 처음부터 끝까지 실행하고 그 결과(수익률, MDD 등)를 반환합니다.
   
   - if __name__ == '__main__': 블록:
     * 주요 역할: 전체 ATR 최적화 과정을 지휘하는 마스터 컨트롤러.
     * 상세 설명:
       * 사용자로부터 모델 정보와 테스트할 ATR 값의 범위를 입력받습니다.
       * 가능한 모든 ATR 파라미터 조합(수백~수천 개) 목록을 생성합니다.
       * 멀티프로세싱(병렬 처리)을 사용해 여러 CPU 코어에 orchestrator_worker 작업을 동시에 할당하여, 수많은 백테스트를 매우 빠른 속도로 실행합니다.
       * 모든 테스트가 완료되면, 결과를 수익률 순으로 정렬하여 최고의 성과를 낸 최적의 ATR 조합을 찾아내고 최종 리포트를 파일로 저장합니다.
"""